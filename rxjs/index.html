<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>rxjs</title>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/rxjs/7.8.1/rxjs.umd.min.js"
      integrity="sha512-D9LDs8YUUVa4V9Gl4Zb+xqRAc7RCzooR3+zzebgK2RMu/KU+dh90pbjEEMzPiSyRSGbSp9j1pZnrO4joGa5WEg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
  </head>
  <body>
    <script>
      // A Function is a lazily evaluated computation that synchronously returns a single value on invocation.
      // A generator is a lazily evaluated computation that synchronously returns zero to (potentially) infinite values on iteration.
      // A Promise is a computation that may (or may not) eventually return a single value.
      // An Observable is a lazily evaluated computation that can synchronously or asynchronously return zero to (potentially) infinite values from the time it's invoked onwards.

      // Core Observable concerns:
      // Creating Observables
      // Subscribing to Observables
      // Executing the Observable
      // Disposing Observables

      // Observable: represents the idea of an invokable collection of future values or events.
      // Observer: is a collection of callbacks that knows how to listen to values delivered by the Observable.
      // Subscription: represents the execution of an Observable, is primarily useful for cancelling the execution.
      // Operators: are pure functions that enable a functional programming style of dealing with collections with operations like map, filter, concat, reduce, etc.
      // Subject: is equivalent to an EventEmitter, and the only way of multicasting a value or event to multiple Observers.
      // Schedulers: are centralized dispatchers to control concurrency, allowing us to coordinate when computation happens on e.g. setTimeout or requestAnimationFrame or others.

      const { Observable } = rxjs;

      const observable = new Observable((subscriber) => {
        try {
          const intervalId = setInterval(() => {
            subscriber.next('hi');
          }, 1000);

          subscriber.next(1);
          subscriber.next(2);
          subscriber.next(3);
        } catch (err) {
          subscriber.error(err);
        }
      });

      const subscription = observable.subscribe({
        next: (x) => console.log(x),
      });

      // subscription.unsubscribe();
    </script>
  </body>
</html>
